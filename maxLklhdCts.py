import scipy.misc as _sm
import scipy.stats as _ss
import kdist as _kd
import kstat as _ks
import warnings as _w
import logerfc_ as _lfc
#  Given data generated by binomial distribution with parameter
#  (p, n), fit this, and try to find (p, n)

def Llklhd(ks, n, p):
    return _N.sum(_N.log(_sm.comb(n, ks)) + ks*_N.log(p) + (n-ks)*_N.log(1 - p))
######
pT = 0.15
nT = 100
N  = 5000

#  With limited data, it appears the CV is underestimated
pMin=0.001
pMax=0.99

cts = _N.random.binomial(nT, pT, size=N)
Mk  = _N.mean(cts)
iMk100 = int(100*Mk)
sdk = _N.std(cts)
cv  = ((sdk*sdk) / Mk)
nmin= max(cts)

ns   = _N.arange(nmin, iMk100, dtype=_N.int)
ps   = _N.linspace(pMin, pMax, 100)
ll   = _N.empty((len(ps), len(ns)))
    
for ni in xrange(len(ns)):
    for pi in xrange(len(ps)):
        p = ps[pi]
        n = ns[ni]
        #  last row of ll (which appears at bottom of imshow) is minimum p
        ll[len(ps)-pi-1, ni] = Llklhd(cts, n, p)

###  first index refers to rows, second index refers to columns
_plt.imshow(ll, aspect=(len(ns)/len(ps)))
_plt.colorbar()
x, y = _N.where(ll == ll.max())
_plt.scatter(y, x, color="black", s=10)
_plt.yticks([0, len(ps)], [pMax, pMin])
_plt.xticks([0, len(ns)], [nmin, iMk100])
_plt.suptitle("N=%(N)d  cv=%(cv).2f  p = %(p).2f (%(pt).2f)   n = %(n)d (%(nt)d)" % {"p" : ps[len(ps)-x-1], "n" : ns[y], "pt" : pT, "nt" : nT, "N" : N, "cv" : cv})

_plt.savefig("maxLklhdCts")
_plt.close()
